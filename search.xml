<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SetTimeout的第三个参数</title>
      <link href="/2020/08/25/setTimout%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/2020/08/25/setTimout%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>setTimeout的第三个参数</p></blockquote><a id="more"></a><h2 id="setTimeout的第三个参数"><a href="#setTimeout的第三个参数" class="headerlink" title="setTimeout的第三个参数"></a>setTimeout的第三个参数</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">scope.setTimeout(function[, delay, param1, param2, ...]);</span><br></pre></td></tr></table></figure><p>param1, param2, param3…作为前面回调函数的附加参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function">(<span class="params">a,b,c</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">&#125;, <span class="number">2000</span>, <span class="string">"my"</span>, <span class="string">"name"</span>, <span class="string">"is starsion"</span>);</span><br><span class="line"><span class="comment">//my name is starsion</span></span><br></pre></td></tr></table></figure><blockquote><p>IE9及更低的版本下是不起作用的，需要使用polyfill。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> __nativeST__ = <span class="built_in">window</span>.setTimeout;</span><br><span class="line"><span class="built_in">window</span>.setTimeout = <span class="function"><span class="keyword">function</span>(<span class="params">vCallback, nDelay <span class="regexp">/*, argumentToPass1, argumentToPass2, etc. */</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> __nativeST__(vCallback <span class="keyword">instanceof</span> <span class="built_in">Function</span> ? <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        vCallback.apply(<span class="literal">null</span>, aArgs);</span><br><span class="line">    &#125; : vCallback, nDelay);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://blog.csdn.net/m0_37682004/article/details/80840519" target="_blank" rel="noopener">setTimeout函数的第三个参数</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" target="_blank" rel="noopener">MDN</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 一些小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reflect</title>
      <link href="/2020/08/11/reflect/"/>
      <url>/2020/08/11/reflect/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API</p></blockquote><a id="more"></a><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><ol><li><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上,未来的新方法将只部署在Reflect对象上</p></li><li><p>修改某些Object方法的返回结果，让其变得更合理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让Object操作都变成函数行为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// 新写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name <span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(obj, name) <span class="comment">//新写法</span></span><br></pre></td></tr></table></figure></li><li><p>Reflect对象的方法与Proxy对象的方法一一对应,这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get'</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'delete'</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  has(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'has'</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)</li></ul><p>具体使用详见<br><a href="https://es6.ruanyifeng.com/#docs/reflect#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">Reflect</a></p><h3 id="Proxy中为啥要用Reflect来完成默认行为"><a href="#Proxy中为啥要用Reflect来完成默认行为" class="headerlink" title="Proxy中为啥要用Reflect来完成默认行为"></a>Proxy中为啥要用Reflect来完成默认行为</h3><ul><li><p>一个基本的proxy demo</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行proxy的get方法'</span>);</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.add)</span><br><span class="line"><span class="comment">// 执行proxy的get方法</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>升级版后的proxy demo</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行proxy的get方法'</span>);</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj2.a = <span class="number">4</span>;</span><br><span class="line">obj2.b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.add)</span><br><span class="line"><span class="comment">// 3，不符合我们的预期，期望是9</span></span><br></pre></td></tr></table></figure></li><li><p>基本版中的receiver</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.add === proxy)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>升级版中的receiver<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.add === obj2) <span class="comment">//receiver代表原始的读操作所在的那个对象。</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>使用Reflect接收receiver中的this<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行proxy的get方法'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj2.a = <span class="number">4</span>;</span><br><span class="line">obj2.b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.add)</span><br><span class="line"><span class="comment">// 9 符合预期</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-Proxy-实现观察者模式"><a href="#使用-Proxy-实现观察者模式" class="headerlink" title="使用 Proxy 实现观察者模式"></a>使用 Proxy 实现观察者模式</h3><blockquote><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(val, &#123;</span><br><span class="line">        <span class="keyword">set</span>: (target, key, value, receiver) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">            queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spin组件</title>
      <link href="/2020/08/06/antd%E6%BA%90%E7%A0%81-spin%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/08/06/antd%E6%BA%90%E7%A0%81-spin%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>antd源码解读之spin组件</p></blockquote><a id="more"></a><h2 id="Spin组件"><a href="#Spin组件" class="headerlink" title="Spin组件"></a>Spin组件</h2><h3 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h3><p><a href="https://ant-design.gitee.io/components/spin-cn/" target="_blank" rel="noopener" title="antd-spin">Spin加载中</a></p><h3 id="二、目录结构"><a href="#二、目录结构" class="headerlink" title="二、目录结构"></a>二、目录结构</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/fd1b42827221088a5b9fe02b6cb2d54e.png" alt="目录结构" title="目录结构"></p><h3 id="三、代码解读"><a href="#三、代码解读" class="headerlink" title="三、代码解读"></a>三、代码解读</h3><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/834f6fcecd4c25e94003f53e0768b516.png" alt="代码整体结构" title="代码整体结构"></p><h4 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h4><ul><li><p><strong>classnames：动态控制类名</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">classNames(<span class="string">'foo'</span>, <span class="string">'bar'</span>); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line">classNames(&#123; <span class="string">'foo-bar'</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo-bar'</span></span><br><span class="line">classNames(&#123; <span class="string">'foo-bar'</span>: <span class="literal">false</span> &#125;); <span class="comment">// =&gt; ''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'b'</span>, &#123; <span class="attr">c</span>: <span class="literal">true</span>, <span class="attr">d</span>: <span class="literal">false</span> &#125;];</span><br><span class="line">classNames(<span class="string">'a'</span>, arr); <span class="comment">// =&gt; 'a b c'</span></span><br></pre></td></tr></table></figure></li><li><p><strong>omit.js：从已经存在的对象中过滤特定属性</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">omit(&#123; <span class="attr">name</span>: <span class="string">'Benjy'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;, [ <span class="string">'name'</span> ]); <span class="comment">// =&gt; &#123; age: 18 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ConfigConsumer, ConfigComsumerProps</strong></p><blockquote><p>来自<span class="label primary">configProvider</span>组件</p></blockquote><p>  一个默认的全局Consumer，用户可通过传ConfigProvider修改context中的值，此处用ConfigConsumer将组件包一层，用于接收context</p></li><li><p><strong>isValidElement</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断参数是否一个合法的 ReactElement，并返回 Boolean 值</span></span><br><span class="line"><span class="keyword">const</span> &#123;isValidElement&#125; = React;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class A &#123;&#125;</span></span><br><span class="line"><span class="comment">// const A = () =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;A /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>cloneElement</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">return</span> React.cloneElement(element, <span class="keyword">typeof</span> props === <span class="string">'function'</span> ? props() : props);</span><br></pre></td></tr></table></figure></li></ul><h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><ul><li><strong>SpinSizes、SpinSize</strong><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> tuple = &lt;T <span class="keyword">extends</span> <span class="built_in">string</span>[]&gt;<span class="function">(<span class="params">...args: T</span>)=&gt;</span> args;</span><br><span class="line"><span class="keyword">const</span> SpinSizes = tuple(<span class="string">'small'</span>, <span class="string">'default'</span>, <span class="string">'large'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> SpinSize = <span class="keyword">typeof</span> SpinSizes[<span class="built_in">number</span>]</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于</span></span><br><span class="line"><span class="keyword">type</span> SpinSizesType = <span class="string">'small'</span> | <span class="string">'default'</span> | <span class="string">'large'</span></span><br><span class="line"><span class="keyword">const</span> SpinSizes: SpinSizesType[] = [<span class="string">'small'</span>, <span class="string">'default'</span>, <span class="string">'large'</span>]</span><br></pre></td></tr></table></figure></li></ul><h4 id="变量-amp-函数定义"><a href="#变量-amp-函数定义" class="headerlink" title="变量&amp;函数定义"></a>变量&amp;函数定义</h4><ul><li>defaultIndicator：默认小菊花样式</li><li>renderIndicator：渲染小菊花</li><li>shouldDelay：初始化时是否spinning</li></ul><h4 id="组件编写"><a href="#组件编写" class="headerlink" title="组件编写"></a>组件编写</h4><ul><li><p>整体结构<br><img src="https://pic.rmb.bdstatic.com/bjh/b783dcc7af893157a4d9396bf000b284.png@s_0,w_1242" alt="变量&amp;函数定义" title="变量&amp;函数定义"></p></li><li><p>状态处理（spinning)</p><ul><li><p>状态更新函数<br><img src="https://pic.rmb.bdstatic.com/bjh/faf7f390723096012ace65352800bc0a.png" alt="状态处理函数" title="状态处理函数"></p></li><li><p>给状态更新函数加上debounce，处理delay<br><img src="https://pic.rmb.bdstatic.com/bjh/a6696831d7129557dec642fcbefb783b.png" alt="加上debounce处理delay" title="加上debounce处理delay"></p></li><li><p>触发状态更新的时间点<br><img src="https://pic.rmb.bdstatic.com/bjh/6cf30cce8f67a87ef8c4438cfa83f835.png" alt="触发状态处理" title="触发状态处理"></p></li></ul></li><li><p>组件渲染</p><ul><li>获取组件前缀</li><li>获取组件classnames</li><li>根据是否有children渲染不同的dom结构<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">isNestedPattern() <span class="comment">// 判断是否有children</span></span><br><span class="line"></span><br><span class="line">renderIndicator() <span class="comment">// render小菊花</span></span><br><span class="line"></span><br><span class="line">renderSpin() <span class="comment">// render组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用configConsumer包一层，能接受ConfigProvider传来的context变量</span></span><br><span class="line">&lt;ConfigConsumer&gt;&#123;<span class="keyword">this</span>.renderSpin&#125;&lt;<span class="regexp">/ConfigConsumer&gt;;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>提供方法允许全局修改默认小菊花样式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> setDefaultIndicator(indicator: React.ReactNode) &#123;</span><br><span class="line">    defaultIndicator = indicator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Spin <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line">Spin.setDefaultIndicator(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure></li><li><p>使用consumer能让组件接收到全局参数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ConfigConsumer</span>&gt;</span>&#123;this.renderSpin&#125;<span class="tag">&lt;/<span class="name">ConfigConsumer</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ConfigProvider</span> <span class="attr">prefixCls</span>=<span class="string">"bjh"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MySpin</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ConfigProvider</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="四、CSS"><a href="#四、CSS" class="headerlink" title="四、CSS"></a>四、CSS</h3><ul><li><p>最外层用项目前缀+组件前缀最为类名</p><p>  <img src="https://pic.rmb.bdstatic.com/bjh/c28f95ce26e14e718b201a9421667e51.png" alt="组件前缀" title="组件前缀"></p></li></ul><ul><li><p>小菊花的实现（4个花瓣的颜色渐变+整个小菊花的旋转）</p><ul><li><p>每个小花瓣渐变色动画<br><img src="https://pic.rmb.bdstatic.com/bjh/456f5d4cd14321d384d838791119e802.png" alt="每个小花瓣渐变色动画" title="每个小花瓣渐变色动画"><br><img src="https://pic.rmb.bdstatic.com/bjh/9226bdee725d312b17baabf65fe7eb5a.png" alt="每个小花瓣渐变色动画" title="每个小花瓣渐变色动画"></p></li><li><p>整体小菊花旋转动画<br><img src="https://pic.rmb.bdstatic.com/bjh/5057a08312d4a634849cdcd7a3c7e41e.png" alt="整体小菊花旋转动画" title="整体小菊花旋转动画"><br><img src="https://pic.rmb.bdstatic.com/bjh/9226bdee725d312b17baabf65fe7eb5a.png" alt="整体小菊花旋转动画" title="整体小菊花旋转动画"></p></li></ul></li></ul><h3 id="五、单测"><a href="#五、单测" class="headerlink" title="五、单测"></a>五、单测</h3><ol><li><code>mountTest</code>：测试组件的正常mount、update和unmount</li><li><code>describe</code>：测试套件，<code>it</code>：测试用例</li><li><code>mount()</code>：将React组件加载为真实DOM节点。mount会渲染当前组件以及所有子组件</li><li><code>toBeFalsy</code>：六个falsy值：false，0，’’，null， undefined，和NaN</li><li><code>render()</code>：render 采用的是第三方库Cheerio的渲染，渲染结果是普通的html结构，对于snapshot使用render比较合适。</li><li><code>toMatchSnapshot()</code>：跟快照一致</li><li><code>instance()</code>：获取组件的实例，和state结合可用来拿内部状态</li></ol><h3 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h3><h4 id="omit的实现"><a href="#omit的实现" class="headerlink" title="omit的实现"></a>omit的实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">omit</span>(<span class="params">obj, fields</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// eslint-disable-next-line prefer-object-spread</span></span><br><span class="line">  <span class="keyword">const</span> shallowCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fields.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = fields[i];</span><br><span class="line">    <span class="keyword">delete</span> shallowCopy[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> shallowCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> omit;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> antd </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hook</title>
      <link href="/2020/05/22/React%20Hook/"/>
      <url>/2020/05/22/React%20Hook/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍react的一些学习点</p></blockquote><a id="more"></a><h1 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h1><h2 id="API基本用法"><a href="#API基本用法" class="headerlink" title="API基本用法"></a>API基本用法</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ul><li><p>使用场景：类似class组件的setState</p></li><li><p>注意事项：</p></li></ul><ol><li>state中的值如果保持相同引用，set的时候不会触发数据更新和页面的重新渲染，特别需要关注第三方回传的数据和dom节点，这俩引用可能会被保持成一样的容易造成Bug</li><li>useState是异步的；class组件中的setState在合成事件和生命周期中是异步的，在原生时间和settimeout中是同步的</li><li>如何拆分state<br>（1）逻辑交互独立，做多个state的独立拆分（2）逻辑相互依赖，合并成一个state</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><ul><li>使用场景：缓存数据</li></ul><ol><li>大量的数据运算</li><li>传给子组件的数据</li><li>自定义hook中的数据</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><ul><li>注意事项</li></ul><ol><li><p>useMemo和React.memo一起使用 = class组件中的pureComponent = 普通class组件 + SCU</p></li><li><p>useMemo其实使用范围很广，啥都能包</p><p> (1)<code>React.memo(com, deps)</code> 相当于 <code>useMemo(() =&gt; com, deps)</code></p></li></ol><pre><code>(2)```useCallback(fn, deps)``` 相当于 ```useMemo(() =&gt; fn, deps)```</code></pre><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><ul><li>使用场景：缓存函数</li></ul><ol><li>传给子组件的函数，事件如果直接绑定在原生dom上，没必要用</li><li>自定义hook中传出来的函数</li></ol><ul><li>注意事项</li></ul><ol><li>尽量让函数的依赖项作为参数传进去，不然如果函数包函数就需要一层一层的找依赖，不利于维护</li></ol><p>eg:（尽量使用上面这种写法）</p><p><img src="https://pic.rmb.bdstatic.com/bjh/30e42d5dd3fce170cfb01d08d4b0d854.png" alt="ok"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/47c1290d761ca6136bfe19b05324cf6f.png" alt="not ok"></p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul><li>使用场景：保存引用，在多次渲染中能够保持不变</li></ul><ol><li>保存dom元素的ref</li><li>解决capture value问题</li><li>解决deps过多的问题</li></ol><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><ul><li>使用场景：有副作用时</li></ul><ol><li>监听&amp;清除</li><li>第二个参数传空，可模拟didmount生命周期</li></ol><h2 id="和class组件的对比"><a href="#和class组件的对比" class="headerlink" title="和class组件的对比"></a>和class组件的对比</h2><h3 id="capture-value"><a href="#capture-value" class="headerlink" title="capture value"></a>capture value</h3><ul><li>hook 有capture value特性，因为props在函数组件中是不可变的。想拿到最新值可以使用useRef，或者用useState的回调</li></ul><p>参见 <a href="https://juejin.im/post/5c8eec1bf265da67cb619e79" target="_blank" rel="noopener">精读《Function VS Class 组件》</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleSyncAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       setCount(count + <span class="number">1</span>) <span class="comment">// wrong! 2秒之后输出之前的值</span></span><br><span class="line">     &#125;, <span class="number">2e3</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">const</span> handleSyncAddWithFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>) <span class="comment">// correct! 2秒之后输出最新的值</span></span><br><span class="line">     &#125;, <span class="number">2e3</span>);</span><br></pre></td></tr></table></figure><ul><li>class组件没有capture value，因为this在 Class Component 中是可变</li></ul><h3 id="state的同异步和合并"><a href="#state的同异步和合并" class="headerlink" title="state的同异步和合并"></a>state的同异步和合并</h3><ul><li><p>useState是异步的，并且没有state的合并</p></li><li><p>class组件中的setState在合成事件和生命周期中是异步的，在原生时间和settimeout中是同步的；并且有state的合并更新特性</p></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><p>hook中使用useMemo + React.memo实现数据的缓存和渲染次数的优化</p></li><li><p>class组件中<br>（1）使用SCU<br>（2）使用purecomponent<br>（由于class组件中的数据都挂载在this上，所以基本不会出现需要用memo进行数据缓存的过程）</p></li></ul><h2 id="和function组件的对比"><a href="#和function组件的对比" class="headerlink" title="和function组件的对比"></a>和function组件的对比</h2><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>可以在函数组件中使用钩子，模拟生命周期，处理state，扩大了函数组件的适用范围</p><h3 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h3><p>新增了useMemo和useCallback提升了一些性能</p><h2 id="编码技巧（坑"><a href="#编码技巧（坑" class="headerlink" title="编码技巧（坑"></a>编码技巧（坑</h2><h3 id="deps过多如何拆分"><a href="#deps过多如何拆分" class="headerlink" title="deps过多如何拆分"></a>deps过多如何拆分</h3><blockquote><p>依赖数组依赖的值最好不要超过 3 个，否则会导致代码会难以维护</p></blockquote><ol><li>去掉不必要的依赖。</li><li>将 Hook 拆分为更小的单元，每个 Hook 依赖于各自的依赖数组。</li><li>通过合并相关的 state，将多个依赖值聚合为一个。</li><li>通过 setState 回调函数获取最新的 state，以减少外部依赖。</li><li>通过 ref 来读取可变变量的值，不过需要注意控制修改它的途径。</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><h3 id="在class组件中使用hook的方法"><a href="#在class组件中使用hook的方法" class="headerlink" title="在class组件中使用hook的方法"></a>在class组件中使用hook的方法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook</span></span><br><span class="line">     ScrollBtn(props) &#123;</span><br><span class="line">        <span class="keyword">const</span> [unreadNum, setUnreadNum] = useState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> [visible, changeVisible] = useState(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">const</span> &#123;scrollToBottom, <span class="keyword">parent</span>&#125; = props;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将setState暴露到外界</span></span><br><span class="line">        useEffect(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">                <span class="keyword">parent</span>.unreadNum = unreadNum;</span><br><span class="line">                <span class="keyword">parent</span>.changeVisible = changeVisible;</span><br><span class="line">            &#125;,</span><br><span class="line">            [unreadNum, <span class="keyword">parent</span>]</span><br><span class="line">        );</span><br><span class="line">        useEffect(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">                <span class="keyword">parent</span>.setUnreadNum = setUnreadNum;</span><br><span class="line">            &#125;,</span><br><span class="line">            [<span class="keyword">parent</span>]</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span>  (</span><br><span class="line">            ......</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 使用hook</span></span><br><span class="line">   &lt;this.ScrollBtn scrollToBottom=&#123;this.scrollToBottom&#125; <span class="keyword">parent</span>=&#123;this&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>自定义hook需要用use开头，而其他命名用use开头会报错，注意命名</p><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">eslint-<span class="keyword">disable</span>-<span class="keyword">line</span> react-hooks/exhaustive-deps</span><br></pre></td></tr></table></figure><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ol><li>callback中包的函数需要在调用的时候传递参数？</li></ol><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ActionWrapper from <span class="string">'./actions'</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">fun</span> = <span class="title">useCallback</span><span class="params">((action)</span></span> =&gt; &#123;console.log(<span class="string">'当前操作是：'</span>, action)&#125;, []);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'delete'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt; <span class="comment">// 使用这种写法或者用bind，每次生成一个新函数，callback就白包了</span></span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'cancel'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt;</span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'add'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ActionWrapper <span class="keyword">from</span> <span class="string">'./actions'</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'当前操作是：'</span>, action)&#125;;</span><br><span class="line"><span class="keyword">const</span> addFun = useCallback(<span class="function">(<span class="params">value</span>) =&gt;</span> fun(value, <span class="string">'add'</span>), []);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;ActionWrapper onClick=&#123;() =&gt; &#123;deleteFun&#125;&#125;&gt;&lt;<span class="regexp">/ActionWrapper&gt; /</span><span class="regexp">/ 使用这种写法又有点傻，所以是要自己写一个缓存吗</span></span><br><span class="line"><span class="regexp">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;cancelFun&#125;&#125;&gt;&lt;/</span>ActionWrapper&gt;</span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;addFun&#125;&#125;&gt;&lt;<span class="regexp">/ActionWrapper&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>hook中的闭包</li><li>hook中的性能和生命周期中的性能开销对比</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></li><li><a href="https://github.com/happylindz/blog/issues/19" target="_blank" rel="noopener">十个案例学会 React Hooks</a></li><li><a href="https://juejin.im/post/5c8eec1bf265da67cb619e79" target="_blank" rel="noopener">精读《Function VS Class 组件》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eventloop</title>
      <link href="/2020/03/18/eventloop/"/>
      <url>/2020/03/18/eventloop/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍与浏览器eventloop与node环境中的eventloop</p></blockquote><a id="more"></a><h2 id="浏览器中的eventloop"><a href="#浏览器中的eventloop" class="headerlink" title="浏览器中的eventloop"></a>浏览器中的eventloop</h2><ul><li>main script运行结束后，会有微任务队列和宏任务队列；</li><li>微任务先执行，执行完队列中的所有微任务；</li><li>拿出宏任务中的第一个任务开始执行，回到第一步</li></ul><p>宏任务：settimeout, setinterval，postMessage，MessageChannel（介个我还没搞懂）</p><p>微任务：promise, async（本质上也是promise),MutationObserver（介个我也没搞懂）</p><p>下面看三个例子：</p><p>1、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then11"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"promise2"</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then21"</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then23"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then12"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// then11</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// then21</span></span><br><span class="line"><span class="comment">// then12</span></span><br><span class="line"><span class="comment">// then23</span></span><br></pre></td></tr></table></figure><p>2、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跟上面一个例子相比多了一个return</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then11"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"promise2"</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then21"</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then23"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then12"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// then11</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// then21</span></span><br><span class="line"><span class="comment">// then23</span></span><br><span class="line"><span class="comment">// then12</span></span><br></pre></td></tr></table></figure><p>3、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">    <span class="keyword">await</span>  async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>  <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"settimeout"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// settimeout</span></span><br></pre></td></tr></table></figure><h2 id="node中的eventloop"><a href="#node中的eventloop" class="headerlink" title="node中的eventloop"></a>node中的eventloop</h2><p>node有一套自己的模型,process.nextTic或者promise会执行在各个阶段之间<br><img src="https://user-gold-cdn.xitu.io/2019/7/24/16c22bfc3d4eee19?w=1352&h=854&f=png&s=53927" alt="2020-03-23-21-32-55"></p><ul><li>NodeJS中宏队列主要有4个</li></ul><p>Timers Queue</p><p>IO Callbacks Queue</p><p>Check Queue</p><p>Close Callbacks Queue</p><blockquote><p>这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。</p></blockquote><ul><li>NodeJS中微队列主要有2个：</li></ul><p>Next Tick Queue：是放置process.nextTick(callback)的回调任务的</p><p>Other Micro Queue：放置其他microtask，比如Promise等</p><blockquote><p>在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。</p></blockquote><p>参考文档：<br><a href="https://segmentfault.com/a/1190000016278115" target="_blank" rel="noopener">带你彻底弄懂Event Loop</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https相关</title>
      <link href="/2020/03/14/https%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/03/14/https%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍与http相比，https的特性以及实现原理</p></blockquote><a id="more"></a><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ol><li>明文传输，信息易被截取</li><li>发送和接收方不会验证报文完整和一致性</li><li>互相不会验证对方身份</li></ol><h2 id="HTTPS做了什么"><a href="#HTTPS做了什么" class="headerlink" title="HTTPS做了什么"></a>HTTPS做了什么</h2><ol><li>数据加密传输</li><li>数据一致性</li><li>身份认证</li></ol><h2 id="HTTPS是怎么做到的"><a href="#HTTPS是怎么做到的" class="headerlink" title="HTTPS是怎么做到的"></a>HTTPS是怎么做到的</h2><p>HTTPS = SSL(TSL) + HTTP<br>即：在http和tcp之间添加了一层SSL安全层，SSL来负责安全部分，内核仍然是http。<br><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-08-15.png" width="50%" height="50%"></p><p>tips: https默认端口号443，http默认端口号80</p><h2 id="SSL（TSL）是怎么做到的"><a href="#SSL（TSL）是怎么做到的" class="headerlink" title="SSL（TSL）是怎么做到的"></a>SSL（TSL）是怎么做到的</h2><ol><li>数据加密传输</li></ol><ul><li><p>对称加密和非对称加密 </p><table><thead><tr><th>-</th><th align="center">对称加密</th><th align="center">非对称加密</th><th align="center">例子</th></tr></thead><tbody><tr><td>定义</td><td align="center">服务端和客户端加密解密使用相同密钥</td><td align="center">客户端使用公钥进行信息加密，服务端使用独有的密钥进行解密</td><td align="center">DES, AES, ChaCha20</td></tr><tr><td>优点</td><td align="center">速度快</td><td align="center">安全性高</td><td align="center">RSA, ECC</td></tr><tr><td>缺点</td><td align="center">密钥会在客户端和服务端之间传输，密钥可能会被拦截，有安全漏洞</td><td align="center">加密算法复杂，加密速度慢</td><td align="center"></td></tr></tbody></table></li><li><p>SSL的数据加密方式——混合加密</p><p>综上表格优缺点，SSL采用对称加密和非对称加密结合的混合加密——<strong>数据传输采用对称加密，对对称加密的密钥采用非对称加密</strong></p><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-09-24.png" width="50%" height="50%"></li></ul><ol start="2"><li>数据一致性</li></ol><ul><li>摘要算法（哈希算法）：它表示输入任意长度的数据，输出固定长度的数据，相同的输入数据始终得到相同的输出，不同的输入数据尽量得到不同的输出。</li><li>SSL的数据一致性方式——利用摘要算法：客服端加加密数据和哈希结果传给服务端，服务端解密数据也计算哈希结果，如果两者一致，则数据一致。<blockquote><p>现在安全性较高的摘要算法是HAMC<br>MAC: MAC 的全称是message authentication code，它通过 MAC 算法从消息和密钥生成，MAC 值允许验证者（也拥有秘密密钥）检测到消息内容的任何更改，从而保护了消息的数据完整性。<br>HMAC：MAC + HASH组合。HMAC 的计算中可以使用任何加密哈希函数，例如 SHA-256 等。</p></blockquote></li></ul><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-21-53.png" width="50%" height="50%"><ol start="3"><li>身份认证</li></ol><ul><li>为认证公钥的合法性，引入权威的第三方机构CA(如沃通CA)。CA负责核实公钥的拥有者的信息，并颁发认证”证书”，同时能够为使用者提供证书验证服务</li><li>CA认证流程<ul><li>服务端将【服务商公钥 + 组织信息 + 个人信息等信息】提交给CA机构进行认证申请</li><li>CA审核确定合法后，会颁发证书，证书中包含【服务商公钥 + 服务商明文信息 + 签名】<ul><li>签名：将【服务商明文信息】经过哈希算法生成【哈希后的摘要】再经过CA的私钥加密生成【签名】</li></ul></li><li>客服端请求时，服务端会返回给客户端证书</li><li>客户端将【服务商明文信息】利用哈希算法生成【哈希后的摘要A】，将证书中返回的【签名】利用CA公钥解密得到【摘要B】，比较【摘要A】和【摘要B】，如果相同则可以确认证书的合法性，即公钥合法<ul><li>tips: CA的公钥内置在客户端内</li></ul></li><li>客户端检查证书中明文信息里的证书时间，授权信息等是否正常，如果一切正常，开始之后的数据交互<img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-26-14.png" width="50%" height="50%"></li></ul></li></ul><p>参考文章：<br><a href="https://juejin.im/post/5e6c4458518825491b11e082#heading-8" target="_blank" rel="noopener">看完这篇 HTTPS，和面试官扯皮就没问题了</a><br><a href="https://juejin.im/post/5af557a3f265da0b9265a498#heading-29" target="_blank" rel="noopener">HTTP和HTTPS详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
