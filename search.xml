<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Promise</title>
      <link href="/2020/08/25/promise/"/>
      <url>/2020/08/25/promise/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Promise相关，内容均来自阮一峰的es6，再整体整理下</p></blockquote><a id="more"></a><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="1-Promise的含义"><a href="#1-Promise的含义" class="headerlink" title="1. Promise的含义"></a>1. Promise的含义</h2><p>promise是一种异步编程解决方案，比传统的事件和回调能合理。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>对象的状态不受外界影响。</p><p>  有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p><p>  Promise对象的状态改变（1）从pending-&gt;fulfilled（2）pending-&gt;rejected。</p><p>  状态发生就不会改变，这时就称为 resolved（已定型）；</p><p>  如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</li><li>Promise对象提供统一的接口，使得控制异步操作更加容易。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法取消Promise</li><li>果不设置回调函数，Promise内部抛出的错误，不会反应到外部</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h2><ol><li>Promise对象是一个构造函数，用来生成Promise实例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p><figure class="highlight plain"><figcaption><span>pending 变为 resolved）</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;reject&#96;&#96;&#96;函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br><span class="line"></span><br><span class="line">2. Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>Promise 新建后就会立即执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure></li><li><p>resolve参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p></li></ol><p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><ol start="5"><li>调用resolve或reject并不会终结 Promise 的参数函数的执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-then方法（promise-prototype-then"><a href="#3-then方法（promise-prototype-then" class="headerlink" title="3. then方法（promise.prototype.then())"></a>3. then方法（promise.prototype.then())</h2><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用es6箭头函数的写法</span></span><br><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="4-catch方法（promise-prototype-catch"><a href="#4-catch方法（promise-prototype-catch" class="headerlink" title="4. catch方法（promise.prototype.catch())"></a>4. catch方法（promise.prototype.catch())</h2><ol><li>错误会先进入reject， 如果没有reject，那就进入catch</li></ol><p>reject抛出的异常会进入catch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">    (success) =&gt; <span class="built_in">console</span>.log(<span class="string">'success'</span>),</span><br><span class="line">    (fail) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fail'</span>, fail)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch'</span>, e);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// fail test1</span></span><br><span class="line"><span class="comment">// catch test2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>状态已经变成resolved，再抛出错误是无效的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li></ol><p>3.一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch()方法，而不使用then()方法的第二个参数。</p><ol start="4"><li><p>Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li><li><p>Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。在promise的catch中就捕获不到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure></li><li><p>一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面的例子中如果catch和then换位置就只能抛出错误，then不会执行</p></li></ol><h2 id="5-finally方法（promise-prototype-catch"><a href="#5-finally方法（promise-prototype-catch" class="headerlink" title="5. finally方法（promise.prototype.catch())"></a>5. finally方法（promise.prototype.catch())</h2><p>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><p>finally方法的回调函数不接受任何参数，这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;<span class="comment">// this指向实例，constructor指向Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6.Promise.all"></a>6.Promise.all</h2><p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p>p的状态由p1、p2、p3决定，分成两种情况。</p><p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p><p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><ol><li><p>例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .then(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .then(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> pickTopRecommendations(books, user));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。</p></li><li><p>如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。</p></li></ol><p>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure><h2 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7.Promise.race"></a>7.Promise.race</h2><p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p><p>Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p><h2 id="7-Promise-allSettled"><a href="#7-Promise-allSettled" class="headerlink" title="7.Promise.allSettled()"></a>7.Promise.allSettled()</h2><p>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">'/api-1'</span>),</span><br><span class="line">  fetch(<span class="string">'/api-2'</span>),</span><br><span class="line">  fetch(<span class="string">'/api-3'</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line">removeLoadingIndicator();</span><br></pre></td></tr></table></figure><p>该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: 'fulfilled', value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: 'rejected', reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>用法的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [ fetch(<span class="string">'index.html'</span>), fetch(<span class="string">'https://does-not-exist/'</span>) ];</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出成功的请求</span></span><br><span class="line"><span class="keyword">const</span> successfulPromises = results.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">'fulfilled'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出失败的请求，并输出原因</span></span><br><span class="line"><span class="keyword">const</span> errors = results</span><br><span class="line">  .filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">'rejected'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">p</span> =&gt;</span> p.reason);</span><br></pre></td></tr></table></figure><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [ <span class="comment">/* ... */</span> ];</span><br><span class="line"><span class="keyword">const</span> requests = urls.map(<span class="function"><span class="params">x</span> =&gt;</span> fetch(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requests);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'所有请求都成功。'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'至少一个请求失败，其他请求可能还没结束。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了Promise.allSettled()，这就很容易了。</p><h2 id="9-Promise-any-——还在提案阶段，先不看"><a href="#9-Promise-any-——还在提案阶段，先不看" class="headerlink" title="9. Promise.any()——还在提案阶段，先不看"></a>9. Promise.any()——还在提案阶段，先不看</h2><h2 id="10-Promise-resolve"><a href="#10-Promise-resolve" class="headerlink" title="10. Promise.resolve()"></a>10. Promise.resolve()</h2><p>将现有对象转为 Promise 对象</p><p>Promise.resolve()等价于下面的写法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p>Promise.resolve方法的参数分成四种情况。</p><ol><li><p>参数是一个 Promise 实例</p><p> 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p></li><li><p>参数是一个thenable对象<br> thenable对象指的是具有then方法的对象，比如下面这个对象。</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</p><p> 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。</p></li><li><p>参数不是具有then方法的对象，或根本就不是对象<br> 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li><li><p>不带有任何参数<br> Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p><p> 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="11-Promise-reject"><a href="#11-Promise-reject" class="headerlink" title="11. Promise.reject()"></a>11. Promise.reject()</h2><p>romise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p><p>注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="12-应用"><a href="#12-应用" class="headerlink" title="12. 应用"></a>12. 应用</h2><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SetTimeout的第三个参数</title>
      <link href="/2020/08/25/setTimout%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/2020/08/25/setTimout%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>setTimeout的第三个参数</p></blockquote><a id="more"></a><h2 id="setTimeout的第三个参数"><a href="#setTimeout的第三个参数" class="headerlink" title="setTimeout的第三个参数"></a>setTimeout的第三个参数</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">scope.setTimeout(function[, delay, param1, param2, ...]);</span><br></pre></td></tr></table></figure><p>param1, param2, param3…作为前面回调函数的附加参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function">(<span class="params">a,b,c</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">&#125;, <span class="number">2000</span>, <span class="string">"my"</span>, <span class="string">"name"</span>, <span class="string">"is starsion"</span>);</span><br><span class="line"><span class="comment">//my name is starsion</span></span><br></pre></td></tr></table></figure><blockquote><p>IE9及更低的版本下是不起作用的，需要使用polyfill。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> __nativeST__ = <span class="built_in">window</span>.setTimeout;</span><br><span class="line"><span class="built_in">window</span>.setTimeout = <span class="function"><span class="keyword">function</span>(<span class="params">vCallback, nDelay <span class="regexp">/*, argumentToPass1, argumentToPass2, etc. */</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> __nativeST__(vCallback <span class="keyword">instanceof</span> <span class="built_in">Function</span> ? <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        vCallback.apply(<span class="literal">null</span>, aArgs);</span><br><span class="line">    &#125; : vCallback, nDelay);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://blog.csdn.net/m0_37682004/article/details/80840519" target="_blank" rel="noopener">setTimeout函数的第三个参数</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" target="_blank" rel="noopener">MDN</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reflect</title>
      <link href="/2020/08/11/reflect/"/>
      <url>/2020/08/11/reflect/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API</p></blockquote><a id="more"></a><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><ol><li><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上,未来的新方法将只部署在Reflect对象上</p></li><li><p>修改某些Object方法的返回结果，让其变得更合理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让Object操作都变成函数行为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// 新写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name <span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(obj, name) <span class="comment">//新写法</span></span><br></pre></td></tr></table></figure></li><li><p>Reflect对象的方法与Proxy对象的方法一一对应,这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get'</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'delete'</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  has(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'has'</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)</li></ul><p>具体使用详见<br><a href="https://es6.ruanyifeng.com/#docs/reflect#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">Reflect</a></p><h3 id="Proxy中为啥要用Reflect来完成默认行为"><a href="#Proxy中为啥要用Reflect来完成默认行为" class="headerlink" title="Proxy中为啥要用Reflect来完成默认行为"></a>Proxy中为啥要用Reflect来完成默认行为</h3><ul><li><p>一个基本的proxy demo</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行proxy的get方法'</span>);</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.add)</span><br><span class="line"><span class="comment">// 执行proxy的get方法</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>升级版后的proxy demo</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行proxy的get方法'</span>);</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj2.a = <span class="number">4</span>;</span><br><span class="line">obj2.b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.add)</span><br><span class="line"><span class="comment">// 3，不符合我们的预期，期望是9</span></span><br></pre></td></tr></table></figure></li><li><p>基本版中的receiver</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.add === proxy)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>升级版中的receiver<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.add === obj2) <span class="comment">//receiver代表原始的读操作所在的那个对象。</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>使用Reflect接收receiver中的this<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> add() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行proxy的get方法'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj2.a = <span class="number">4</span>;</span><br><span class="line">obj2.b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.add)</span><br><span class="line"><span class="comment">// 9 符合预期</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-Proxy-实现观察者模式"><a href="#使用-Proxy-实现观察者模式" class="headerlink" title="使用 Proxy 实现观察者模式"></a>使用 Proxy 实现观察者模式</h3><blockquote><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(val, &#123;</span><br><span class="line">        <span class="keyword">set</span>: (target, key, value, receiver) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">            queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spin组件</title>
      <link href="/2020/08/06/antd%E6%BA%90%E7%A0%81-spin%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/08/06/antd%E6%BA%90%E7%A0%81-spin%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>antd源码解读之spin组件</p></blockquote><a id="more"></a><h2 id="Spin组件"><a href="#Spin组件" class="headerlink" title="Spin组件"></a>Spin组件</h2><h3 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h3><p><a href="https://ant-design.gitee.io/components/spin-cn/" target="_blank" rel="noopener" title="antd-spin">Spin加载中</a></p><h3 id="二、目录结构"><a href="#二、目录结构" class="headerlink" title="二、目录结构"></a>二、目录结构</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/fd1b42827221088a5b9fe02b6cb2d54e.png" alt="目录结构" title="目录结构"></p><h3 id="三、代码解读"><a href="#三、代码解读" class="headerlink" title="三、代码解读"></a>三、代码解读</h3><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/834f6fcecd4c25e94003f53e0768b516.png" alt="代码整体结构" title="代码整体结构"></p><h4 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h4><ul><li><p><strong>classnames：动态控制类名</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">classNames(<span class="string">'foo'</span>, <span class="string">'bar'</span>); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line">classNames(&#123; <span class="string">'foo-bar'</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo-bar'</span></span><br><span class="line">classNames(&#123; <span class="string">'foo-bar'</span>: <span class="literal">false</span> &#125;); <span class="comment">// =&gt; ''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'b'</span>, &#123; <span class="attr">c</span>: <span class="literal">true</span>, <span class="attr">d</span>: <span class="literal">false</span> &#125;];</span><br><span class="line">classNames(<span class="string">'a'</span>, arr); <span class="comment">// =&gt; 'a b c'</span></span><br></pre></td></tr></table></figure></li><li><p><strong>omit.js：从已经存在的对象中过滤特定属性</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">omit(&#123; <span class="attr">name</span>: <span class="string">'Benjy'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;, [ <span class="string">'name'</span> ]); <span class="comment">// =&gt; &#123; age: 18 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ConfigConsumer, ConfigComsumerProps</strong></p><blockquote><p>来自<span class="label primary">configProvider</span>组件</p></blockquote><p>  一个默认的全局Consumer，用户可通过传ConfigProvider修改context中的值，此处用ConfigConsumer将组件包一层，用于接收context</p></li><li><p><strong>isValidElement</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断参数是否一个合法的 ReactElement，并返回 Boolean 值</span></span><br><span class="line"><span class="keyword">const</span> &#123;isValidElement&#125; = React;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class A &#123;&#125;</span></span><br><span class="line"><span class="comment">// const A = () =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;A /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>cloneElement</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">return</span> React.cloneElement(element, <span class="keyword">typeof</span> props === <span class="string">'function'</span> ? props() : props);</span><br></pre></td></tr></table></figure></li></ul><h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><ul><li><strong>SpinSizes、SpinSize</strong><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> tuple = &lt;T <span class="keyword">extends</span> <span class="built_in">string</span>[]&gt;<span class="function">(<span class="params">...args: T</span>)=&gt;</span> args;</span><br><span class="line"><span class="keyword">const</span> SpinSizes = tuple(<span class="string">'small'</span>, <span class="string">'default'</span>, <span class="string">'large'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> SpinSize = <span class="keyword">typeof</span> SpinSizes[<span class="built_in">number</span>]</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于</span></span><br><span class="line"><span class="keyword">type</span> SpinSizesType = <span class="string">'small'</span> | <span class="string">'default'</span> | <span class="string">'large'</span></span><br><span class="line"><span class="keyword">const</span> SpinSizes: SpinSizesType[] = [<span class="string">'small'</span>, <span class="string">'default'</span>, <span class="string">'large'</span>]</span><br></pre></td></tr></table></figure></li></ul><h4 id="变量-amp-函数定义"><a href="#变量-amp-函数定义" class="headerlink" title="变量&amp;函数定义"></a>变量&amp;函数定义</h4><ul><li>defaultIndicator：默认小菊花样式</li><li>renderIndicator：渲染小菊花</li><li>shouldDelay：初始化时是否spinning</li></ul><h4 id="组件编写"><a href="#组件编写" class="headerlink" title="组件编写"></a>组件编写</h4><ul><li><p>整体结构<br><img src="https://pic.rmb.bdstatic.com/bjh/b783dcc7af893157a4d9396bf000b284.png@s_0,w_1242" alt="变量&amp;函数定义" title="变量&amp;函数定义"></p></li><li><p>状态处理（spinning)</p><ul><li><p>状态更新函数<br><img src="https://pic.rmb.bdstatic.com/bjh/faf7f390723096012ace65352800bc0a.png" alt="状态处理函数" title="状态处理函数"></p></li><li><p>给状态更新函数加上debounce，处理delay<br><img src="https://pic.rmb.bdstatic.com/bjh/a6696831d7129557dec642fcbefb783b.png" alt="加上debounce处理delay" title="加上debounce处理delay"></p></li><li><p>触发状态更新的时间点<br><img src="https://pic.rmb.bdstatic.com/bjh/6cf30cce8f67a87ef8c4438cfa83f835.png" alt="触发状态处理" title="触发状态处理"></p></li></ul></li><li><p>组件渲染</p><ul><li>获取组件前缀</li><li>获取组件classnames</li><li>根据是否有children渲染不同的dom结构<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">isNestedPattern() <span class="comment">// 判断是否有children</span></span><br><span class="line"></span><br><span class="line">renderIndicator() <span class="comment">// render小菊花</span></span><br><span class="line"></span><br><span class="line">renderSpin() <span class="comment">// render组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用configConsumer包一层，能接受ConfigProvider传来的context变量</span></span><br><span class="line">&lt;ConfigConsumer&gt;&#123;<span class="keyword">this</span>.renderSpin&#125;&lt;<span class="regexp">/ConfigConsumer&gt;;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>提供方法允许全局修改默认小菊花样式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> setDefaultIndicator(indicator: React.ReactNode) &#123;</span><br><span class="line">    defaultIndicator = indicator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Spin <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line">Spin.setDefaultIndicator(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure></li><li><p>使用consumer能让组件接收到全局参数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ConfigConsumer</span>&gt;</span>&#123;this.renderSpin&#125;<span class="tag">&lt;/<span class="name">ConfigConsumer</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ConfigProvider</span> <span class="attr">prefixCls</span>=<span class="string">"bjh"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MySpin</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ConfigProvider</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="四、CSS"><a href="#四、CSS" class="headerlink" title="四、CSS"></a>四、CSS</h3><ul><li><p>最外层用项目前缀+组件前缀最为类名</p><p>  <img src="https://pic.rmb.bdstatic.com/bjh/c28f95ce26e14e718b201a9421667e51.png" alt="组件前缀" title="组件前缀"></p></li></ul><ul><li><p>小菊花的实现（4个花瓣的颜色渐变+整个小菊花的旋转）</p><ul><li><p>每个小花瓣渐变色动画<br><img src="https://pic.rmb.bdstatic.com/bjh/456f5d4cd14321d384d838791119e802.png" alt="每个小花瓣渐变色动画" title="每个小花瓣渐变色动画"><br><img src="https://pic.rmb.bdstatic.com/bjh/9226bdee725d312b17baabf65fe7eb5a.png" alt="每个小花瓣渐变色动画" title="每个小花瓣渐变色动画"></p></li><li><p>整体小菊花旋转动画<br><img src="https://pic.rmb.bdstatic.com/bjh/5057a08312d4a634849cdcd7a3c7e41e.png" alt="整体小菊花旋转动画" title="整体小菊花旋转动画"><br><img src="https://pic.rmb.bdstatic.com/bjh/9226bdee725d312b17baabf65fe7eb5a.png" alt="整体小菊花旋转动画" title="整体小菊花旋转动画"></p></li></ul></li></ul><h3 id="五、单测"><a href="#五、单测" class="headerlink" title="五、单测"></a>五、单测</h3><ol><li><code>mountTest</code>：测试组件的正常mount、update和unmount</li><li><code>describe</code>：测试套件，<code>it</code>：测试用例</li><li><code>mount()</code>：将React组件加载为真实DOM节点。mount会渲染当前组件以及所有子组件</li><li><code>toBeFalsy</code>：六个falsy值：false，0，’’，null， undefined，和NaN</li><li><code>render()</code>：render 采用的是第三方库Cheerio的渲染，渲染结果是普通的html结构，对于snapshot使用render比较合适。</li><li><code>toMatchSnapshot()</code>：跟快照一致</li><li><code>instance()</code>：获取组件的实例，和state结合可用来拿内部状态</li></ol><h3 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h3><h4 id="omit的实现"><a href="#omit的实现" class="headerlink" title="omit的实现"></a>omit的实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">omit</span>(<span class="params">obj, fields</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// eslint-disable-next-line prefer-object-spread</span></span><br><span class="line">  <span class="keyword">const</span> shallowCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fields.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = fields[i];</span><br><span class="line">    <span class="keyword">delete</span> shallowCopy[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> shallowCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> omit;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hook</title>
      <link href="/2020/05/22/React%20Hook/"/>
      <url>/2020/05/22/React%20Hook/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍react的一些学习点</p></blockquote><a id="more"></a><h1 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h1><h2 id="API基本用法"><a href="#API基本用法" class="headerlink" title="API基本用法"></a>API基本用法</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ul><li><p>使用场景：类似class组件的setState</p></li><li><p>注意事项：</p></li></ul><ol><li>state中的值如果保持相同引用，set的时候不会触发数据更新和页面的重新渲染，特别需要关注第三方回传的数据和dom节点，这俩引用可能会被保持成一样的容易造成Bug</li><li>useState是异步的；class组件中的setState在合成事件和生命周期中是异步的，在原生时间和settimeout中是同步的</li><li>如何拆分state<br>（1）逻辑交互独立，做多个state的独立拆分（2）逻辑相互依赖，合并成一个state</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><ul><li>使用场景：缓存数据</li></ul><ol><li>大量的数据运算</li><li>传给子组件的数据</li><li>自定义hook中的数据</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><ul><li>注意事项</li></ul><ol><li><p>useMemo和React.memo一起使用 = class组件中的pureComponent = 普通class组件 + SCU</p></li><li><p>useMemo其实使用范围很广，啥都能包</p><p> (1)<code>React.memo(com, deps)</code> 相当于 <code>useMemo(() =&gt; com, deps)</code></p></li></ol><pre><code>(2)```useCallback(fn, deps)``` 相当于 ```useMemo(() =&gt; fn, deps)```</code></pre><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><ul><li>使用场景：缓存函数</li></ul><ol><li>传给子组件的函数，事件如果直接绑定在原生dom上，没必要用</li><li>自定义hook中传出来的函数</li></ol><ul><li>注意事项</li></ul><ol><li>尽量让函数的依赖项作为参数传进去，不然如果函数包函数就需要一层一层的找依赖，不利于维护</li></ol><p>eg:（尽量使用上面这种写法）</p><p><img src="https://pic.rmb.bdstatic.com/bjh/30e42d5dd3fce170cfb01d08d4b0d854.png" alt="ok"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/47c1290d761ca6136bfe19b05324cf6f.png" alt="not ok"></p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul><li>使用场景：保存引用，在多次渲染中能够保持不变</li></ul><ol><li>保存dom元素的ref</li><li>解决capture value问题</li><li>解决deps过多的问题</li></ol><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><ul><li>使用场景：有副作用时</li></ul><ol><li>监听&amp;清除</li><li>第二个参数传空，可模拟didmount生命周期</li></ol><h2 id="和class组件的对比"><a href="#和class组件的对比" class="headerlink" title="和class组件的对比"></a>和class组件的对比</h2><h3 id="capture-value"><a href="#capture-value" class="headerlink" title="capture value"></a>capture value</h3><ul><li>hook 有capture value特性，因为props在函数组件中是不可变的。想拿到最新值可以使用useRef，或者用useState的回调</li></ul><p>参见 <a href="https://juejin.im/post/5c8eec1bf265da67cb619e79" target="_blank" rel="noopener">精读《Function VS Class 组件》</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleSyncAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       setCount(count + <span class="number">1</span>) <span class="comment">// wrong! 2秒之后输出之前的值</span></span><br><span class="line">     &#125;, <span class="number">2e3</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">const</span> handleSyncAddWithFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>) <span class="comment">// correct! 2秒之后输出最新的值</span></span><br><span class="line">     &#125;, <span class="number">2e3</span>);</span><br></pre></td></tr></table></figure><ul><li>class组件没有capture value，因为this在 Class Component 中是可变</li></ul><h3 id="state的同异步和合并"><a href="#state的同异步和合并" class="headerlink" title="state的同异步和合并"></a>state的同异步和合并</h3><ul><li><p>useState是异步的，并且没有state的合并</p></li><li><p>class组件中的setState在合成事件和生命周期中是异步的，在原生时间和settimeout中是同步的；并且有state的合并更新特性</p></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><p>hook中使用useMemo + React.memo实现数据的缓存和渲染次数的优化</p></li><li><p>class组件中<br>（1）使用SCU<br>（2）使用purecomponent<br>（由于class组件中的数据都挂载在this上，所以基本不会出现需要用memo进行数据缓存的过程）</p></li></ul><h2 id="和function组件的对比"><a href="#和function组件的对比" class="headerlink" title="和function组件的对比"></a>和function组件的对比</h2><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>可以在函数组件中使用钩子，模拟生命周期，处理state，扩大了函数组件的适用范围</p><h3 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h3><p>新增了useMemo和useCallback提升了一些性能</p><h2 id="编码技巧（坑"><a href="#编码技巧（坑" class="headerlink" title="编码技巧（坑"></a>编码技巧（坑</h2><h3 id="deps过多如何拆分"><a href="#deps过多如何拆分" class="headerlink" title="deps过多如何拆分"></a>deps过多如何拆分</h3><blockquote><p>依赖数组依赖的值最好不要超过 3 个，否则会导致代码会难以维护</p></blockquote><ol><li>去掉不必要的依赖。</li><li>将 Hook 拆分为更小的单元，每个 Hook 依赖于各自的依赖数组。</li><li>通过合并相关的 state，将多个依赖值聚合为一个。</li><li>通过 setState 回调函数获取最新的 state，以减少外部依赖。</li><li>通过 ref 来读取可变变量的值，不过需要注意控制修改它的途径。</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><h3 id="在class组件中使用hook的方法"><a href="#在class组件中使用hook的方法" class="headerlink" title="在class组件中使用hook的方法"></a>在class组件中使用hook的方法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook</span></span><br><span class="line">     ScrollBtn(props) &#123;</span><br><span class="line">        <span class="keyword">const</span> [unreadNum, setUnreadNum] = useState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> [visible, changeVisible] = useState(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">const</span> &#123;scrollToBottom, <span class="keyword">parent</span>&#125; = props;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将setState暴露到外界</span></span><br><span class="line">        useEffect(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">                <span class="keyword">parent</span>.unreadNum = unreadNum;</span><br><span class="line">                <span class="keyword">parent</span>.changeVisible = changeVisible;</span><br><span class="line">            &#125;,</span><br><span class="line">            [unreadNum, <span class="keyword">parent</span>]</span><br><span class="line">        );</span><br><span class="line">        useEffect(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">                <span class="keyword">parent</span>.setUnreadNum = setUnreadNum;</span><br><span class="line">            &#125;,</span><br><span class="line">            [<span class="keyword">parent</span>]</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span>  (</span><br><span class="line">            ......</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 使用hook</span></span><br><span class="line">   &lt;this.ScrollBtn scrollToBottom=&#123;this.scrollToBottom&#125; <span class="keyword">parent</span>=&#123;this&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>自定义hook需要用use开头，而其他命名用use开头会报错，注意命名</p><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">eslint-<span class="keyword">disable</span>-<span class="keyword">line</span> react-hooks/exhaustive-deps</span><br></pre></td></tr></table></figure><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ol><li>callback中包的函数需要在调用的时候传递参数？</li></ol><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ActionWrapper from <span class="string">'./actions'</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">fun</span> = <span class="title">useCallback</span><span class="params">((action)</span></span> =&gt; &#123;console.log(<span class="string">'当前操作是：'</span>, action)&#125;, []);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'delete'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt; <span class="comment">// 使用这种写法或者用bind，每次生成一个新函数，callback就白包了</span></span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'cancel'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt;</span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'add'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ActionWrapper <span class="keyword">from</span> <span class="string">'./actions'</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'当前操作是：'</span>, action)&#125;;</span><br><span class="line"><span class="keyword">const</span> addFun = useCallback(<span class="function">(<span class="params">value</span>) =&gt;</span> fun(value, <span class="string">'add'</span>), []);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;ActionWrapper onClick=&#123;() =&gt; &#123;deleteFun&#125;&#125;&gt;&lt;<span class="regexp">/ActionWrapper&gt; /</span><span class="regexp">/ 使用这种写法又有点傻，所以是要自己写一个缓存吗</span></span><br><span class="line"><span class="regexp">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;cancelFun&#125;&#125;&gt;&lt;/</span>ActionWrapper&gt;</span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;addFun&#125;&#125;&gt;&lt;<span class="regexp">/ActionWrapper&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>hook中的闭包</li><li>hook中的性能和生命周期中的性能开销对比</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></li><li><a href="https://github.com/happylindz/blog/issues/19" target="_blank" rel="noopener">十个案例学会 React Hooks</a></li><li><a href="https://juejin.im/post/5c8eec1bf265da67cb619e79" target="_blank" rel="noopener">精读《Function VS Class 组件》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eventloop</title>
      <link href="/2020/03/18/eventloop/"/>
      <url>/2020/03/18/eventloop/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍与浏览器eventloop与node环境中的eventloop</p></blockquote><a id="more"></a><h2 id="浏览器中的eventloop"><a href="#浏览器中的eventloop" class="headerlink" title="浏览器中的eventloop"></a>浏览器中的eventloop</h2><ul><li>main script运行结束后，会有微任务队列和宏任务队列；</li><li>微任务先执行，执行完队列中的所有微任务；</li><li>拿出宏任务中的第一个任务开始执行，回到第一步</li></ul><p>宏任务：settimeout, setinterval，postMessage，MessageChannel（介个我还没搞懂）</p><p>微任务：promise, async（本质上也是promise),MutationObserver（介个我也没搞懂）</p><p>下面看三个例子：</p><p>1、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then11"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"promise2"</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then21"</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then23"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then12"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// then11</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// then21</span></span><br><span class="line"><span class="comment">// then12</span></span><br><span class="line"><span class="comment">// then23</span></span><br></pre></td></tr></table></figure><p>2、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跟上面一个例子相比多了一个return</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then11"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"promise2"</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then21"</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then23"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then12"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// then11</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// then21</span></span><br><span class="line"><span class="comment">// then23</span></span><br><span class="line"><span class="comment">// then12</span></span><br></pre></td></tr></table></figure><p>3、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">    <span class="keyword">await</span>  async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>  <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"settimeout"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// settimeout</span></span><br></pre></td></tr></table></figure><h2 id="node中的eventloop"><a href="#node中的eventloop" class="headerlink" title="node中的eventloop"></a>node中的eventloop</h2><p>node有一套自己的模型,process.nextTic或者promise会执行在各个阶段之间<br><img src="https://user-gold-cdn.xitu.io/2019/7/24/16c22bfc3d4eee19?w=1352&h=854&f=png&s=53927" alt="2020-03-23-21-32-55"></p><ul><li>NodeJS中宏队列主要有4个</li></ul><p>Timers Queue</p><p>IO Callbacks Queue</p><p>Check Queue</p><p>Close Callbacks Queue</p><blockquote><p>这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。</p></blockquote><ul><li>NodeJS中微队列主要有2个：</li></ul><p>Next Tick Queue：是放置process.nextTick(callback)的回调任务的</p><p>Other Micro Queue：放置其他microtask，比如Promise等</p><blockquote><p>在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。</p></blockquote><p>参考文档：<br><a href="https://segmentfault.com/a/1190000016278115" target="_blank" rel="noopener">带你彻底弄懂Event Loop</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https相关</title>
      <link href="/2020/03/14/https%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/03/14/https%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍与http相比，https的特性以及实现原理</p></blockquote><a id="more"></a><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ol><li>明文传输，信息易被截取</li><li>发送和接收方不会验证报文完整和一致性</li><li>互相不会验证对方身份</li></ol><h2 id="HTTPS做了什么"><a href="#HTTPS做了什么" class="headerlink" title="HTTPS做了什么"></a>HTTPS做了什么</h2><ol><li>数据加密传输</li><li>数据一致性</li><li>身份认证</li></ol><h2 id="HTTPS是怎么做到的"><a href="#HTTPS是怎么做到的" class="headerlink" title="HTTPS是怎么做到的"></a>HTTPS是怎么做到的</h2><p>HTTPS = SSL(TSL) + HTTP<br>即：在http和tcp之间添加了一层SSL安全层，SSL来负责安全部分，内核仍然是http。<br><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-08-15.png" width="50%" height="50%"></p><p>tips: https默认端口号443，http默认端口号80</p><h2 id="SSL（TSL）是怎么做到的"><a href="#SSL（TSL）是怎么做到的" class="headerlink" title="SSL（TSL）是怎么做到的"></a>SSL（TSL）是怎么做到的</h2><ol><li>数据加密传输</li></ol><ul><li><p>对称加密和非对称加密 </p><table><thead><tr><th>-</th><th align="center">对称加密</th><th align="center">非对称加密</th><th align="center">例子</th></tr></thead><tbody><tr><td>定义</td><td align="center">服务端和客户端加密解密使用相同密钥</td><td align="center">客户端使用公钥进行信息加密，服务端使用独有的密钥进行解密</td><td align="center">DES, AES, ChaCha20</td></tr><tr><td>优点</td><td align="center">速度快</td><td align="center">安全性高</td><td align="center">RSA, ECC</td></tr><tr><td>缺点</td><td align="center">密钥会在客户端和服务端之间传输，密钥可能会被拦截，有安全漏洞</td><td align="center">加密算法复杂，加密速度慢</td><td align="center"></td></tr></tbody></table></li><li><p>SSL的数据加密方式——混合加密</p><p>综上表格优缺点，SSL采用对称加密和非对称加密结合的混合加密——<strong>数据传输采用对称加密，对对称加密的密钥采用非对称加密</strong></p><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-09-24.png" width="50%" height="50%"></li></ul><ol start="2"><li>数据一致性</li></ol><ul><li>摘要算法（哈希算法）：它表示输入任意长度的数据，输出固定长度的数据，相同的输入数据始终得到相同的输出，不同的输入数据尽量得到不同的输出。</li><li>SSL的数据一致性方式——利用摘要算法：客服端加加密数据和哈希结果传给服务端，服务端解密数据也计算哈希结果，如果两者一致，则数据一致。<blockquote><p>现在安全性较高的摘要算法是HAMC<br>MAC: MAC 的全称是message authentication code，它通过 MAC 算法从消息和密钥生成，MAC 值允许验证者（也拥有秘密密钥）检测到消息内容的任何更改，从而保护了消息的数据完整性。<br>HMAC：MAC + HASH组合。HMAC 的计算中可以使用任何加密哈希函数，例如 SHA-256 等。</p></blockquote></li></ul><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-21-53.png" width="50%" height="50%"><ol start="3"><li>身份认证</li></ol><ul><li>为认证公钥的合法性，引入权威的第三方机构CA(如沃通CA)。CA负责核实公钥的拥有者的信息，并颁发认证”证书”，同时能够为使用者提供证书验证服务</li><li>CA认证流程<ul><li>服务端将【服务商公钥 + 组织信息 + 个人信息等信息】提交给CA机构进行认证申请</li><li>CA审核确定合法后，会颁发证书，证书中包含【服务商公钥 + 服务商明文信息 + 签名】<ul><li>签名：将【服务商明文信息】经过哈希算法生成【哈希后的摘要】再经过CA的私钥加密生成【签名】</li></ul></li><li>客服端请求时，服务端会返回给客户端证书</li><li>客户端将【服务商明文信息】利用哈希算法生成【哈希后的摘要A】，将证书中返回的【签名】利用CA公钥解密得到【摘要B】，比较【摘要A】和【摘要B】，如果相同则可以确认证书的合法性，即公钥合法<ul><li>tips: CA的公钥内置在客户端内</li></ul></li><li>客户端检查证书中明文信息里的证书时间，授权信息等是否正常，如果一切正常，开始之后的数据交互<img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-26-14.png" width="50%" height="50%"></li></ul></li></ul><p>参考文章：<br><a href="https://juejin.im/post/5e6c4458518825491b11e082#heading-8" target="_blank" rel="noopener">看完这篇 HTTPS，和面试官扯皮就没问题了</a><br><a href="https://juejin.im/post/5af557a3f265da0b9265a498#heading-29" target="_blank" rel="noopener">HTTP和HTTPS详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
