<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React Hook</title>
      <link href="/2020/05/22/React%20Hook/"/>
      <url>/2020/05/22/React%20Hook/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍react的一些学习点</p></blockquote><a id="more"></a><h1 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h1><h2 id="API基本用法"><a href="#API基本用法" class="headerlink" title="API基本用法"></a>API基本用法</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ul><li><p>使用场景：类似class组件的setState</p></li><li><p>注意事项：</p></li></ul><ol><li>state中的值如果保持相同引用，set的时候不会触发数据更新和页面的重新渲染，特别需要关注第三方回传的数据和dom节点，这俩引用可能会被保持成一样的容易造成Bug</li><li>useState是异步的；class组件中的setState在合成事件和生命周期中是异步的，在原生时间和settimeout中是同步的</li><li>如何拆分state<br>（1）逻辑交互独立，做多个state的独立拆分（2）逻辑相互依赖，合并成一个state</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><ul><li>使用场景：缓存数据</li></ul><ol><li>大量的数据运算</li><li>传给子组件的数据</li><li>自定义hook中的数据</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><ul><li>注意事项</li></ul><ol><li><p>useMemo和React.memo一起使用 = class组件中的pureComponent = 普通class组件 + SCU</p></li><li><p>useMemo其实使用范围很广，啥都能包</p><p> (1)<code>React.memo(com, deps)</code> 相当于 <code>useMemo(() =&gt; com, deps)</code></p></li></ol><pre><code>(2)```useCallback(fn, deps)``` 相当于 ```useMemo(() =&gt; fn, deps)```</code></pre><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><ul><li>使用场景：缓存函数</li></ul><ol><li>传给子组件的函数，事件如果直接绑定在原生dom上，没必要用</li><li>自定义hook中传出来的函数</li></ol><ul><li>注意事项</li></ul><ol><li>尽量让函数的依赖项作为参数传进去，不然如果函数包函数就需要一层一层的找依赖，不利于维护</li></ol><p>eg:（尽量使用上面这种写法）</p><p><img src="https://pic.rmb.bdstatic.com/bjh/30e42d5dd3fce170cfb01d08d4b0d854.png" alt="ok"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/47c1290d761ca6136bfe19b05324cf6f.png" alt="not ok"></p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul><li>使用场景：保存引用，在多次渲染中能够保持不变</li></ul><ol><li>保存dom元素的ref</li><li>解决capture value问题</li><li>解决deps过多的问题</li></ol><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><ul><li>使用场景：有副作用时</li></ul><ol><li>监听&amp;清除</li><li>第二个参数传空，可模拟didmount生命周期</li></ol><h2 id="和class组件的对比"><a href="#和class组件的对比" class="headerlink" title="和class组件的对比"></a>和class组件的对比</h2><h3 id="capture-value"><a href="#capture-value" class="headerlink" title="capture value"></a>capture value</h3><ul><li>hook 有capture value特性，因为props在函数组件中是不可变的。想拿到最新值可以使用useRef，或者用useState的回调</li></ul><p>参见 <a href="https://juejin.im/post/5c8eec1bf265da67cb619e79" target="_blank" rel="noopener">精读《Function VS Class 组件》</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleSyncAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       setCount(count + <span class="number">1</span>) <span class="comment">// wrong! 2秒之后输出之前的值</span></span><br><span class="line">     &#125;, <span class="number">2e3</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">const</span> handleSyncAddWithFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>) <span class="comment">// correct! 2秒之后输出最新的值</span></span><br><span class="line">     &#125;, <span class="number">2e3</span>);</span><br></pre></td></tr></table></figure><ul><li>class组件没有capture value，因为this在 Class Component 中是可变</li></ul><h3 id="state的同异步和合并"><a href="#state的同异步和合并" class="headerlink" title="state的同异步和合并"></a>state的同异步和合并</h3><ul><li><p>useState是异步的，并且没有state的合并</p></li><li><p>class组件中的setState在合成事件和生命周期中是异步的，在原生时间和settimeout中是同步的；并且有state的合并更新特性</p></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><p>hook中使用useMemo + React.memo实现数据的缓存和渲染次数的优化</p></li><li><p>class组件中<br>（1）使用SCU<br>（2）使用purecomponent<br>（由于class组件中的数据都挂载在this上，所以基本不会出现需要用memo进行数据缓存的过程）</p></li></ul><h2 id="和function组件的对比"><a href="#和function组件的对比" class="headerlink" title="和function组件的对比"></a>和function组件的对比</h2><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>可以在函数组件中使用钩子，模拟生命周期，处理state，扩大了函数组件的适用范围</p><h3 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h3><p>新增了useMemo和useCallback提升了一些性能</p><h2 id="编码技巧（坑"><a href="#编码技巧（坑" class="headerlink" title="编码技巧（坑"></a>编码技巧（坑</h2><h3 id="deps过多如何拆分"><a href="#deps过多如何拆分" class="headerlink" title="deps过多如何拆分"></a>deps过多如何拆分</h3><blockquote><p>依赖数组依赖的值最好不要超过 3 个，否则会导致代码会难以维护</p></blockquote><ol><li>去掉不必要的依赖。</li><li>将 Hook 拆分为更小的单元，每个 Hook 依赖于各自的依赖数组。</li><li>通过合并相关的 state，将多个依赖值聚合为一个。</li><li>通过 setState 回调函数获取最新的 state，以减少外部依赖。</li><li>通过 ref 来读取可变变量的值，不过需要注意控制修改它的途径。</li></ol><p>参见 <a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><h3 id="在class组件中使用hook的方法"><a href="#在class组件中使用hook的方法" class="headerlink" title="在class组件中使用hook的方法"></a>在class组件中使用hook的方法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook</span></span><br><span class="line">     ScrollBtn(props) &#123;</span><br><span class="line">        <span class="keyword">const</span> [unreadNum, setUnreadNum] = useState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> [visible, changeVisible] = useState(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">const</span> &#123;scrollToBottom, <span class="keyword">parent</span>&#125; = props;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将setState暴露到外界</span></span><br><span class="line">        useEffect(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">                <span class="keyword">parent</span>.unreadNum = unreadNum;</span><br><span class="line">                <span class="keyword">parent</span>.changeVisible = changeVisible;</span><br><span class="line">            &#125;,</span><br><span class="line">            [unreadNum, <span class="keyword">parent</span>]</span><br><span class="line">        );</span><br><span class="line">        useEffect(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">                <span class="keyword">parent</span>.setUnreadNum = setUnreadNum;</span><br><span class="line">            &#125;,</span><br><span class="line">            [<span class="keyword">parent</span>]</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span>  (</span><br><span class="line">            ......</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 使用hook</span></span><br><span class="line">   &lt;this.ScrollBtn scrollToBottom=&#123;this.scrollToBottom&#125; <span class="keyword">parent</span>=&#123;this&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>自定义hook需要用use开头，而其他命名用use开头会报错，注意命名</p><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">eslint-<span class="keyword">disable</span>-<span class="keyword">line</span> react-hooks/exhaustive-deps</span><br></pre></td></tr></table></figure><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ol><li>callback中包的函数需要在调用的时候传递参数？</li></ol><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ActionWrapper from <span class="string">'./actions'</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">fun</span> = <span class="title">useCallback</span><span class="params">((action)</span></span> =&gt; &#123;console.log(<span class="string">'当前操作是：'</span>, action)&#125;, []);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'delete'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt; <span class="comment">// 使用这种写法或者用bind，每次生成一个新函数，callback就白包了</span></span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'cancel'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt;</span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;<span class="function"><span class="title">fun</span><span class="params">(<span class="string">'add'</span>)</span></span>&#125;&#125;&gt;&lt;/ActionWrapper&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ActionWrapper <span class="keyword">from</span> <span class="string">'./actions'</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'当前操作是：'</span>, action)&#125;;</span><br><span class="line"><span class="keyword">const</span> addFun = useCallback(<span class="function">(<span class="params">value</span>) =&gt;</span> fun(value, <span class="string">'add'</span>), []);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;ActionWrapper onClick=&#123;() =&gt; &#123;deleteFun&#125;&#125;&gt;&lt;<span class="regexp">/ActionWrapper&gt; /</span><span class="regexp">/ 使用这种写法又有点傻，所以是要自己写一个缓存吗</span></span><br><span class="line"><span class="regexp">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;cancelFun&#125;&#125;&gt;&lt;/</span>ActionWrapper&gt;</span><br><span class="line">    &lt;ActionWrapper onClick=&#123;() =&gt; &#123;addFun&#125;&#125;&gt;&lt;<span class="regexp">/ActionWrapper&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>hook中的闭包</li><li>hook中的性能和生命周期中的性能开销对比</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/85969406?utm_source=wechat_session&utm_medium=social&utm_oi=667823971379187712" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></li><li><a href="https://github.com/happylindz/blog/issues/19" target="_blank" rel="noopener">十个案例学会 React Hooks</a></li><li><a href="https://juejin.im/post/5c8eec1bf265da67cb619e79" target="_blank" rel="noopener">精读《Function VS Class 组件》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eventloop</title>
      <link href="/2020/03/18/eventloop/"/>
      <url>/2020/03/18/eventloop/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍与浏览器eventloop与node环境中的eventloop</p></blockquote><a id="more"></a><h2 id="浏览器中的eventloop"><a href="#浏览器中的eventloop" class="headerlink" title="浏览器中的eventloop"></a>浏览器中的eventloop</h2><ul><li>main script运行结束后，会有微任务队列和宏任务队列；</li><li>微任务先执行，执行完队列中的所有微任务；</li><li>拿出宏任务中的第一个任务开始执行，回到第一步</li></ul><p>宏任务：settimeout, setinterval，postMessage，MessageChannel（介个我还没搞懂）</p><p>微任务：promise, async（本质上也是promise),MutationObserver（介个我也没搞懂）</p><p>下面看三个例子：</p><p>1、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then11"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"promise2"</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then21"</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then23"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then12"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// then11</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// then21</span></span><br><span class="line"><span class="comment">// then12</span></span><br><span class="line"><span class="comment">// then23</span></span><br></pre></td></tr></table></figure><p>2、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跟上面一个例子相比多了一个return</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then11"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"promise2"</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then21"</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"then23"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then12"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// then11</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// then21</span></span><br><span class="line"><span class="comment">// then23</span></span><br><span class="line"><span class="comment">// then12</span></span><br></pre></td></tr></table></figure><p>3、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">    <span class="keyword">await</span>  async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>  <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"settimeout"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码的运行结果是：</span></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// settimeout</span></span><br></pre></td></tr></table></figure><h2 id="node中的eventloop"><a href="#node中的eventloop" class="headerlink" title="node中的eventloop"></a>node中的eventloop</h2><p>node有一套自己的模型,process.nextTic或者promise会执行在各个阶段之间<br><img src="https://user-gold-cdn.xitu.io/2019/7/24/16c22bfc3d4eee19?w=1352&h=854&f=png&s=53927" alt="2020-03-23-21-32-55"></p><ul><li>NodeJS中宏队列主要有4个</li></ul><p>Timers Queue</p><p>IO Callbacks Queue</p><p>Check Queue</p><p>Close Callbacks Queue</p><blockquote><p>这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。</p></blockquote><ul><li>NodeJS中微队列主要有2个：</li></ul><p>Next Tick Queue：是放置process.nextTick(callback)的回调任务的</p><p>Other Micro Queue：放置其他microtask，比如Promise等</p><blockquote><p>在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。</p></blockquote><p>参考文档：<br><a href="https://segmentfault.com/a/1190000016278115" target="_blank" rel="noopener">带你彻底弄懂Event Loop</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动日记(持续更新)</title>
      <link href="/2020/03/16/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/03/16/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>准备建个页专门用来存运动情况，每天开一个太浪费了。【更新至3.17】</p></blockquote><a id="more"></a><p>3.16：今天偷懒了，只练了<a href="https://www.bilibili.com/video/av50314054?p=3" target="_blank" rel="noopener">美丽芭蕾的瘦腿第三套</a>。今天是周一，明显感觉时间不够用，白天和晚上都有很多工作，准备把早上的时间利用起来，每天早上练习20分钟的体态训练吧，加油。</p><p>3.17 腰部+手臂+hiit燃脂+肩颈拉伸</p>]]></content>
      
      
      <categories>
          
          <category> 习惯养成计划 </category>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动日记(四)</title>
      <link href="/2020/03/15/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E5%9B%9B/"/>
      <url>/2020/03/15/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【3月15日】 背部、肩部、舒缓运动</p></blockquote><a id="more"></a><p>最近身体状态比较特殊啦，多以舒缓和上身小运动为主！希望可以坚持下来！fighting！</p><p>一组背部运动<a href="https://www.bilibili.com/video/av88812230" target="_blank" rel="noopener">B站美背大法-坚持4天</a></p><p>一组手臂运动<a href="https://www.bilibili.com/video/av90866754" target="_blank" rel="noopener">B站手臂运动-坚持4天</a></p><p>一组肩背手臂拉伸<a href="https://www.bilibili.com/video/av92672384" target="_blank" rel="noopener">8分钟改善【斜方肌肥厚】拉伸打造-坚持3天</a></p>]]></content>
      
      
      <categories>
          
          <category> 习惯养成计划 </category>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动日记(三)</title>
      <link href="/2020/03/14/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E4%B8%89/"/>
      <url>/2020/03/14/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【3月14日】 背部、肩部、手臂</p></blockquote><a id="more"></a><p>最近身体状态比较特殊啦，多以舒缓和上身小运动为主！希望可以坚持下来！fighting！</p><p>一组背部运动<a href="https://www.bilibili.com/video/av88812230" target="_blank" rel="noopener">B站美背大法-坚持3天</a></p><p>一组手臂运动<a href="https://www.bilibili.com/video/av90866754" target="_blank" rel="noopener">B站手臂运动-坚持3天</a></p><p>一组肩部运动<a href="https://www.bilibili.com/video/av92583471" target="_blank" rel="noopener">甩掉斜方肌-坚持1天</a></p><p>一组肩背手臂拉伸<a href="https://www.bilibili.com/video/av92672384" target="_blank" rel="noopener">8分钟改善【斜方肌肥厚】拉伸打造-坚持2天</a></p>]]></content>
      
      
      <categories>
          
          <category> 习惯养成计划 </category>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https相关</title>
      <link href="/2020/03/14/https%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/03/14/https%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍与http相比，https的特性以及实现原理</p></blockquote><a id="more"></a><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ol><li>明文传输，信息易被截取</li><li>发送和接收方不会验证报文完整和一致性</li><li>互相不会验证对方身份</li></ol><h2 id="HTTPS做了什么"><a href="#HTTPS做了什么" class="headerlink" title="HTTPS做了什么"></a>HTTPS做了什么</h2><ol><li>数据加密传输</li><li>数据一致性</li><li>身份认证</li></ol><h2 id="HTTPS是怎么做到的"><a href="#HTTPS是怎么做到的" class="headerlink" title="HTTPS是怎么做到的"></a>HTTPS是怎么做到的</h2><p>HTTPS = SSL(TSL) + HTTP<br>即：在http和tcp之间添加了一层SSL安全层，SSL来负责安全部分，内核仍然是http。<br><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-08-15.png" width="50%" height="50%"></p><p>tips: https默认端口号443，http默认端口号80</p><h2 id="SSL（TSL）是怎么做到的"><a href="#SSL（TSL）是怎么做到的" class="headerlink" title="SSL（TSL）是怎么做到的"></a>SSL（TSL）是怎么做到的</h2><ol><li>数据加密传输</li></ol><ul><li><p>对称加密和非对称加密 </p><table><thead><tr><th>-</th><th align="center">对称加密</th><th align="center">非对称加密</th><th align="center">例子</th></tr></thead><tbody><tr><td>定义</td><td align="center">服务端和客户端加密解密使用相同密钥</td><td align="center">客户端使用公钥进行信息加密，服务端使用独有的密钥进行解密</td><td align="center">DES, AES, ChaCha20</td></tr><tr><td>优点</td><td align="center">速度快</td><td align="center">安全性高</td><td align="center">RSA, ECC</td></tr><tr><td>缺点</td><td align="center">密钥会在客户端和服务端之间传输，密钥可能会被拦截，有安全漏洞</td><td align="center">加密算法复杂，加密速度慢</td><td align="center"></td></tr></tbody></table></li><li><p>SSL的数据加密方式——混合加密</p><p>综上表格优缺点，SSL采用对称加密和非对称加密结合的混合加密——<strong>数据传输采用对称加密，对对称加密的密钥采用非对称加密</strong></p><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-09-24.png" width="50%" height="50%"></li></ul><ol start="2"><li>数据一致性</li></ol><ul><li>摘要算法（哈希算法）：它表示输入任意长度的数据，输出固定长度的数据，相同的输入数据始终得到相同的输出，不同的输入数据尽量得到不同的输出。</li><li>SSL的数据一致性方式——利用摘要算法：客服端加加密数据和哈希结果传给服务端，服务端解密数据也计算哈希结果，如果两者一致，则数据一致。<blockquote><p>现在安全性较高的摘要算法是HAMC<br>MAC: MAC 的全称是message authentication code，它通过 MAC 算法从消息和密钥生成，MAC 值允许验证者（也拥有秘密密钥）检测到消息内容的任何更改，从而保护了消息的数据完整性。<br>HMAC：MAC + HASH组合。HMAC 的计算中可以使用任何加密哈希函数，例如 SHA-256 等。</p></blockquote></li></ul><img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-21-53.png" width="50%" height="50%"><ol start="3"><li>身份认证</li></ol><ul><li>为认证公钥的合法性，引入权威的第三方机构CA(如沃通CA)。CA负责核实公钥的拥有者的信息，并颁发认证”证书”，同时能够为使用者提供证书验证服务</li><li>CA认证流程<ul><li>服务端将【服务商公钥 + 组织信息 + 个人信息等信息】提交给CA机构进行认证申请</li><li>CA审核确定合法后，会颁发证书，证书中包含【服务商公钥 + 服务商明文信息 + 签名】<ul><li>签名：将【服务商明文信息】经过哈希算法生成【哈希后的摘要】再经过CA的私钥加密生成【签名】</li></ul></li><li>客服端请求时，服务端会返回给客户端证书</li><li>客户端将【服务商明文信息】利用哈希算法生成【哈希后的摘要A】，将证书中返回的【签名】利用CA公钥解密得到【摘要B】，比较【摘要A】和【摘要B】，如果相同则可以确认证书的合法性，即公钥合法<ul><li>tips: CA的公钥内置在客户端内</li></ul></li><li>客户端检查证书中明文信息里的证书时间，授权信息等是否正常，如果一切正常，开始之后的数据交互<img src="http://q780g4x9h.bkt.clouddn.com/2020-03-15-14-26-14.png" width="50%" height="50%"></li></ul></li></ul><p>参考文章：<br><a href="https://juejin.im/post/5e6c4458518825491b11e082#heading-8" target="_blank" rel="noopener">看完这篇 HTTPS，和面试官扯皮就没问题了</a><br><a href="https://juejin.im/post/5af557a3f265da0b9265a498#heading-29" target="_blank" rel="noopener">HTTP和HTTPS详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动日记(二)</title>
      <link href="/2020/03/13/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E4%BA%8C/"/>
      <url>/2020/03/13/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【3月13日】 背部、手臂、肩颈拉伸</p></blockquote><a id="more"></a><p>最近身体状态比较特殊啦，多以舒缓和上身小运动为主！希望可以坚持下来！fighting！</p><p>一组背部运动<a href="https://www.bilibili.com/video/av88812230" target="_blank" rel="noopener">B站美背大法-坚持2天</a></p><p>一组手臂运动<a href="https://www.bilibili.com/video/av90866754" target="_blank" rel="noopener">B站手臂运动-坚持2天</a></p><p>一组肩背手臂拉伸<a href="https://www.bilibili.com/video/av92672384" target="_blank" rel="noopener">8分钟改善【斜方肌肥厚】拉伸打造-坚持1天</a></p>]]></content>
      
      
      <categories>
          
          <category> 习惯养成计划 </category>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动日记(一)</title>
      <link href="/2020/03/12/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E4%B8%80/"/>
      <url>/2020/03/12/%E8%BF%90%E5%8A%A8%E6%97%A5%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【3月12日】 背部、肩部、手臂</p></blockquote><a id="more"></a><p>最近身体状态比较特殊啦，多以舒缓和上身小运动为主！希望可以坚持下来！fighting！</p><p>一组肩部和背部热身 <a href="https://www.bilibili.com/video/av24009054" target="_blank" rel="noopener">B站美丽芭蕾-累计1天</a></p><p>一组背部运动<a href="https://www.bilibili.com/video/av88812230" target="_blank" rel="noopener">B站美背大法-坚持1天</a></p><p>一组手臂运动<a href="https://www.bilibili.com/video/av90866754" target="_blank" rel="noopener">B站手臂运动-坚持1天</a></p>]]></content>
      
      
      <categories>
          
          <category> 习惯养成计划 </category>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运动 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
